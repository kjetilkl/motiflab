package org.motiflab.engine.util;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;


/**
 * This class wraps another InputStream and removes certain content from that 
 * stream on-the-fly before it is passed to the consumer.
 * This was partly generated by ChatGPT
 */

public class FilterPatternInputStream extends FilterInputStream {
    private final String pattern;
    private final byte[] patternBytes;
    private byte[] buffer;
    private int bufferPos;
    private int bufferEnd;

    
    /**
     * Wraps another InputStream and removes the patterns if it is found
     * @param in The stream to wrap
     * @param pattern The literal string to remove from the stream
     */
    public FilterPatternInputStream(InputStream in, String pattern) {
        super(in);
        this.pattern = pattern;
        this.patternBytes = pattern.getBytes();
        this.buffer = new byte[8192]; // Buffer size
        this.bufferPos = 0;
        this.bufferEnd = 0;
    }

    @Override
    public int read() throws IOException {
        if (bufferPos >= bufferEnd) {
            fillBuffer();
            if (bufferEnd == -1) {
                return -1;
            }
        }
        return buffer[bufferPos++] & 0xFF;
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        int bytesRead = 0;
        while (len > 0) {
            if (bufferPos >= bufferEnd) {
                fillBuffer();
                if (bufferEnd == -1) {
                    return bytesRead == 0 ? -1 : bytesRead;
                }
            }
            int bytesToCopy = Math.min(bufferEnd - bufferPos, len);
            System.arraycopy(buffer, bufferPos, b, off, bytesToCopy);
            bufferPos += bytesToCopy;
            off += bytesToCopy;
            len -= bytesToCopy;
            bytesRead += bytesToCopy;
        }
        return bytesRead;
    }

    private void fillBuffer() throws IOException {
        bufferPos = 0; // reset buffer position to start of buffer when filling it
        bufferEnd = 0;
        int bytesRead;
        while ((bytesRead = in.read(buffer, bufferEnd, buffer.length - bufferEnd)) != -1) {
            bufferEnd += bytesRead;
            if (bufferEnd >= patternBytes.length) {
                int patternPos = indexOfPattern(buffer, bufferEnd, patternBytes);
                if (patternPos != -1) {
                    System.arraycopy(buffer, patternPos + patternBytes.length, buffer, patternPos, bufferEnd - (patternPos + patternBytes.length));
                    bufferEnd -= patternBytes.length;
                }
            }
            if (bufferEnd < buffer.length) {
                break;
            }
        }
        if (bufferEnd == 0) {
            bufferEnd = -1; // End of stream
        }
    }

    private int indexOfPattern(byte[] buffer, int bufferEnd, byte[] pattern) {
        for (int i = 0; i <= bufferEnd - pattern.length; i++) {
            boolean match = true;
            for (int j = 0; j < pattern.length; j++) {
                if (buffer[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                return i;
            }
        }
        return -1;
    }
}